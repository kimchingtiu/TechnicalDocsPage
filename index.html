<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Technical Docs Page</title>
	<link rel="stylesheet" type="text/css" href="technical.css">
</head>
<body>
<nav id="navbar">
  <header>C++ Programming Language</header>
  <ul>
    <li><a class="nav-link" href="#Introduction">Introduction</a></li>
    <li>
      <a class="nav-link" href="#What_you_should_already_know"
        >History</a
      >
    </li>
    <li>
      <a class="nav-link" href="#JavaScript_and_Java">Philosophy</a>
    </li>
    <li><a class="nav-link" href="#Hello_world">Standardization</a></li>
    <li><a class="nav-link" href="#Variables">Language</a></li>
    <li>
      <a class="nav-link" href="#Declaring_variables">Encapsulation</a>
    </li>
    <li><a class="nav-link" href="#Variable_scope">Inheritance</a></li>
    <li><a class="nav-link" href="#Global_variables">Operators and operator overloading</a></li>
    <li><a class="nav-link" href="#Constants">Polymorphism</a></li>
    <li><a class="nav-link" href="#Data_types">Static polymorphism</a></li>
    <li>
      <a class="nav-link" href="#if...else_statement">Dynamic polymorphism</a>
    </li>
    <li><a class="nav-link" href="#while_statement">Virtual member functions</a></li>
    <li>
      <a class="nav-link" href="#Function_declarations"
        >Lambda expressions</a
      >
    </li>
    <li><a class="nav-link" href="#Reference">Exception handling</a></li>
  </ul>
</nav>
<main id="main-doc">
  <section class="main-section" id="Introduction">
    <header>Introduction</header>
    <article>
      <p>
         C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or "C with Classes". The language has expanded significantly over time, and modern C++ now has object-oriented, generic, and functional features in addition to facilities for low-level memory manipulation. It is almost always implemented as a compiled language, and many vendors provide C++ compilers, including the Free Software Foundation, LLVM, Microsoft, Intel, Oracle, and IBM, so it is available on many platforms.
      </p>

      <p>
        C++ was designed with an orientation toward system programming and embedded, resource-constrained software and large systems, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g. e-commerce, web search, or databases), and performance-critical applications (e.g. telephone switches or space probes).
      </p>
      
        <p>
         C++ is standardized by the International Organization for Standardization (ISO), with the latest standard version ratified and published by ISO in December 2020 as ISO/IEC 14882:2020 (informally known as C++20). The C++ programming language was initially standardized in 1998 as ISO/IEC 14882:1998, which was then amended by the C++03, C++11, C++14, and C++17 standards. The current C++20 standard supersedes these with new features and an enlarged standard library. Before the initial standardization in 1998, C++ was developed by Danish computer scientist Bjarne Stroustrup at Bell Labs since 1979 as an extension of the C language; he wanted an efficient and flexible language similar to C that also provided high-level features for program organization.Since 2012, C++ has been on a three-year release schedule with C++23 as the next planned standard.
        </p>
             
    </article>
  </section>
  <section class="main-section" id="What_you_should_already_know">
    <header>History</header>
    <article>
      <p>This guide assumes you have the following basic background:</p>

      <ul>
        <li>
          In 1979, Bjarne Stroustrup, a Danish computer scientist, began work on "C with Classes", the predecessor to C++. The motivation for creating a new language originated from Stroustrup's experience in programming for his PhD thesis. Stroustrup found that Simula had features that were very helpful for large software development, but the language was too slow for practical use, while BCPL was fast but too low-level to be suitable for large software development. When Stroustrup started working in AT&T Bell Labs, he had the problem of analyzing the UNIX kernel with respect to distributed computing. Remembering his PhD experience, Stroustrup set out to enhance the C language with Simula-like features. C was chosen because it was general-purpose, fast, portable and widely used. As well as C and Simula's influences, other languages also influenced this new language, including ALGOL 68, Ada, CLU and ML.Initially, Stroustrup's "C with Classes" added features to the C compiler, Cpre, including classes, derived classes, strong typing, inlining and default arguments.
        </li>
        <li>
          In 1998, C++98 was released, standardizing the language, and a minor update (C++03) was released in 2003.

After C++98, C++ evolved relatively slowly until, in 2011, the C++11 standard was released, adding numerous new features, enlarging the standard library further, and providing more facilities to C++ programmers. After a minor C++14 update released in December 2014, various new additions were introduced in C++17. After becoming finalized in February 2020, a draft of the C++20 standard was approved on 4 September 2020 and officially published on 15 December 2020.

On January 3, 2018, Stroustrup was announced as the 2018 winner of the Charles Stark Draper Prize for Engineering, "for conceptualizing and developing the C++ programming language".

As of 2021 C++ ranked fourth on the TIOBE index, a measure of the popularity of programming languages, after C, Java, and Python.
        </li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="JavaScript_and_Java">
    <header>Philosophy</header>
    <article>
      <p>
        Throughout C++'s life, its development and evolution has been guided by a set of principles:
      </p>
      <ul>
      <li>
        It must be driven by actual problems and its features should be immediately useful in real world programs.
      </li>
        <li>
          Every feature should be implementable (with a reasonably obvious way to do so).
        </li>
        <li>
         Programmers should be free to pick their own programming style, and that style should be fully supported by C++. 
        </li>
        <li>
         Allowing a useful feature is more important than preventing every possible misuse of C++. 
        </li>
         <li>
           It should provide facilities for organising programs into separate, well-defined parts, and provide facilities for combining separately developed parts.
         </li>
         <li>
           No implicit violations of the type system (but allow explicit violations; that is, those explicitly requested by the programmer).
         </li>
         <li>
           User-created types need to have the same support and performance as built-in types.
         </li>
         <li>
           Unused features should not negatively impact created executables (e.g. in lower performance).
         </li>
         <li>
           There should be no language beneath C++ (except assembly language).
         </li>
         <li>
           C++ should work alongside other existing programming languages, rather than fostering its own separate and incompatible programming environment.
         </li>
         <li>
           If the programmer's intent is unknown, allow the programmer to specify it by providing manual control.
         </li>
        </ul>
    </article>
  </section>
  <section class="main-section" id="Hello_world">
    <header>Standardization</header>
    <article>
      C++ is standardized by an ISO working group known as JTC1/SC22/WG21. So far, it has published six revisions of the C++ standard and is currently working on the next revision, C++23.

In 1998, the ISO working group standardized C++ for the first time as ISO/IEC 14882:1998, which is informally known as C++98. In 2003, it published a new version of the C++ standard called ISO/IEC 14882:2003, which fixed problems identified in C++98.
      

      As part of the standardization process, ISO also publishes technical reports and specifications:
      <ul>
        <li>
          ISO/IEC TR 18015:2006 on the use of C++ in embedded systems and on performance implications of C++ language and library features,
        </li>
         <li>
           ISO/IEC TR 19768:2007 (also known as the C++ Technical Report 1) on library extensions mostly integrated into C++11,
         </li>
         <li>
           ISO/IEC TR 29124:2010 on special mathematical functions, integrated into C++17
         </li>
         <li>
           ISO/IEC TR 24733:2011 on decimal floating-point arithmetic,
         </li>
         <li>
           ISO/IEC TS 18822:2015 on the standard filesystem library, integrated into C++17
         </li>
         <li>
           ISO/IEC TS 19570:2015 on parallel versions of the standard library algorithms, integrated into C++17
         </li>
         <li>
           
ISO/IEC TS 19841:2015 on software transactional memory,
         </li>
         <li>
           ISO/IEC TS 19568:2015 on a new set of library extensions, some of which are already integrated into C++17,
         </li>
         <li>
           ISO/IEC TS 19217:2015 on the C++ concepts, integrated into C++20
         </li>
         <li>
           ISO/IEC TS 19571:2016 on the library extensions for concurrency, some of which are already integrated into C++20
         </li>
         <li>
           ISO/IEC TS 19568:2017 on a new set of general-purpose library extensions
         </li>
         <li>
           ISO/IEC TS 21425:2017 on the library extensions for ranges, integrated into C++20
         </li>
         <li>
           ISO/IEC TS 22277:2017 on coroutines, integrated into C++20
         </li>
         <li>
           ISO/IEC TS 19216:2018 on the networking library
         </li>
        <li>
          ISO/IEC TS 21544:2018 on modules, integrated into C++20
        </li>
        <li>
          ISO/IEC TS 19570:2018 on a new set of library extensions for parallelism
        </li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="Variables">
    <header>Language</header>
    <p>
      The C++ language has two main components: a direct mapping of hardware features provided primarily by the C subset, and zero-overhead abstractions based on those mappings. Stroustrup describes C++ as "a light-weight abstraction programming language [designed] for building and using efficient and elegant abstractions";and "offering both hardware access and abstraction is the basis of C++. Doing it efficiently is what distinguishes it from other languages."


    </p>
    <p>
     C++ inherits most of C's syntax. The following is Bjarne Stroustrup's version of the Hello world program that uses the C++ Standard Library stream facility to write a message to standard output:
    </p>
    
    <code>
      #include <iostream>

int main()
{
    std::cout << "Hello, world!\n";
}
    </code>
  </section>
  <section class="main-section" id="Declaring_variables">
    <header>Encapsulation</header>
    <article>
      
      <p>
        Encapsulation is the hiding of information to ensure that data structures and operators are used as intended and to make the usage model more obvious to the developer. C++ provides the ability to define classes and functions as its primary encapsulation mechanisms. Within a class, members can be declared as either public, protected, or private to explicitly enforce encapsulation. A public member of the class is accessible to any function. A private member is accessible only to functions that are members of that class and to functions and classes explicitly granted access permission by the class ("friends"). A protected member is accessible to members of classes that inherit from the class in addition to the class itself and any friends.
      </p>
      <p>
       The object-oriented principle ensures the encapsulation of all and only the functions that access the internal representation of a type. C++ supports this principle via member functions and friend functions, but it does not enforce it. Programmers can declare parts or all of the representation of a type to be public, and they are allowed to make public entities not part of the representation of a type. Therefore, C++ supports not just object-oriented programming, but other decomposition paradigms such as modular programming.
      </p>
      <p>
       It is generally considered good practice to make all data private or protected, and to make public only those functions that are part of a minimal interface for users of the class. This can hide the details of data implementation, allowing the designer to later fundamentally change the implementation without changing the interface in any way.
      </p>
    </article>
  </section>
  <section class="main-section" id="Variable_scope">
    <header>Inheritance</header>
    <article>
      <p>
       Inheritance allows one data type to acquire properties of other data types. Inheritance from a base class may be declared as public, protected, or private. This access specifier determines whether unrelated and derived classes can access the inherited public and protected members of the base class. Only public inheritance corresponds to what is usually meant by "inheritance". The other two forms are much less frequently used. If the access specifier is omitted, a "class" inherits privately, while a "struct" inherits publicly. Base classes may be declared as virtual; this is called virtual inheritance. Virtual inheritance ensures that only one instance of a base class exists in the inheritance graph, avoiding some of the ambiguity problems of multiple inheritance.
      </p>

      <p>
        Multiple inheritance is a C++ feature allowing a class to be derived from more than one base class; this allows for more elaborate inheritance relationships. For example, a "Flying Cat" class can inherit from both "Cat" and "Flying Mammal". Some other languages, such as C# or Java, accomplish something similar (although more limited) by allowing inheritance of multiple interfaces while restricting the number of base classes to one (interfaces, unlike classes, provide only declarations of member functions, no implementation or member data). An interface as in C# and Java can be defined in C++ as a class containing only pure virtual functions, often known as an abstract base class or "ABC". The member functions of such an abstract base class are normally explicitly defined in the derived class, not inherited implicitly. C++ virtual inheritance exhibits an ambiguity resolution feature called dominance.
      </p>
     
     
    </article>
  </section>
  <section class="main-section" id="Global_variables">
    <header>Operators and operator overloading</header>
    Operators and operator overloading
    <article>
      <p>
       C++ provides more than 35 operators, covering basic arithmetic, bit manipulation, indirection, comparisons, logical operations and others. Almost all operators can be overloaded for user-defined types, with a few notable exceptions such as member access (. and .*) as well as the conditional operator. The rich set of overloadable operators is central to making user-defined types in C++ seem like built-in types.
      </p>

      <p>
       Overloadable operators are also an essential part of many advanced C++ programming techniques, such as smart pointers. Overloading an operator does not change the precedence of calculations involving the operator, nor does it change the number of operands that the operator uses (any operand may however be ignored by the operator, though it will be evaluated prior to execution). Overloaded "&&" and "||" operators lose their short-circuit evaluation property.
      </p>
    </article>
  </section>
  <section class="main-section" id="Constants">
    <header>Polymorphism</header>
    <article>
      <p>
       Polymorphism enables one common interface for many implementations, and for objects to act differently under different circumstances.

C++ supports several kinds of static (resolved at compile-time) and dynamic (resolved at run-time) polymorphisms, supported by the language features described above. Compile-time polymorphism does not allow for certain run-time decisions, while runtime polymorphism typically incurs a performance penalty.
      </p>
    </article>
  </section>
  <section class="main-section" id="Data_types">
    <header>Dynamic polymorphism</header>
    <article>
      <p>Inheritance</p>
      <p>Variable pointers and references to a base class type in C++ can also refer to objects of any derived classes of that type. This allows arrays and other kinds of containers to hold pointers to objects of differing types (references cannot be directly held in containers). This enables dynamic (run-time) polymorphism, where the referred objects can behave differently, depending on their (actual, derived) types.
</p>
     
          <p>C++ also provides the dynamic_cast operator, which allows code to safely attempt conversion of an object, via a base reference/pointer, to a more derived type: downcasting. The attempt is necessary as often one does not know which derived type is referenced. (Upcasting, conversion to a more general type, can always be checked/performed at compile-time via static_cast, as ancestral classes are specified in the derived class's interface, visible to all callers.) dynamic_cast relies on run-time type information (RTTI), metadata in the program that enables differentiating types and their relationships. If a dynamic_cast to a pointer fails, the result is the nullptr constant, whereas if the destination is a reference (which cannot be null), the cast throws an exception. Objects known to be of a certain derived type can be cast to that with static_cast, bypassing RTTI and the safe runtime type-checking of dynamic_cast, so this should be used only if the programmer is very confident the cast is, and will always be, valid.</p>
          
            
    </article>
  </section>
  <section class="main-section" id="if...else_statement">
    <header>Virtual member functions</header>
    <article>
      <p>Ordinarily, when a function in a derived class overrides a function in a base class, the function to call is determined by the type of the object. A given function is overridden when there exists no difference in the number or type of parameters between two or more definitions of that function. Hence, at compile time, it may not be possible to determine the type of the object and therefore the correct function to call, given only a base class pointer; the decision is therefore put off until runtime. This is called dynamic dispatch. Virtual member functions or methods allow the most specific implementation of the function to be called, according to the actual run-time type of the object. In C++ implementations, this is commonly done using virtual function tables. If the object type is known, this may be bypassed by prepending a fully qualified class name before the function call, but in general calls to virtual functions are resolved at run time.</p>
      <p>
        In addition to standard member functions, operator overloads and destructors can be virtual. An inexact rule based on practical experience states that if any function in the class is virtual, the destructor should be as well. As the type of an object at its creation is known at compile time, constructors, and by extension copy constructors, cannot be virtual. Nonetheless a situation may arise where a copy of an object needs to be created when a pointer to a derived object is passed as a pointer to a base object. In such a case, a common solution is to create a clone() (or similar) virtual function that creates and returns a copy of the derived class when called.
      </p>
      <p>
        A member function can also be made "pure virtual" by appending it with = 0 after the closing parenthesis and before the semicolon. A class containing a pure virtual function is called an abstract class. Objects cannot be created from an abstract class; they can only be derived from. Any derived class inherits the virtual function as pure and must provide a non-pure definition of it (and all other pure virtual functions) before objects of the derived class can be created. A program that attempts to create an object of a class with a pure virtual member function or inherited pure virtual member function is ill-formed.
      </p>

    </article>
  </section>
  <section class="main-section" id="while_statement">
    <header>Lambda expressions</header>
    <article>
     C++ provides support for anonymous functions, also known as lambda expressions, with the following form:
      <code>[capture](parameters) -> return_type { function_body }</code> 
     Since C++20, you can write template parameters without the keyword template:
      <code>
        [capture]<template_parameters>(parameters) -> return_type { function_body }
      </code>
        If the lambda takes no parameters, the () can be omitted, that is,
        <code>
          [capture] -> return_type { function_body }
        </code>
        Also, the return type of a lambda expression can be automatically inferred, if possible, e.g.:
        <code>
          [](int x, int y) { return x + y; } // inferred
[](int x, int y) -> int { return x + y; } // explicit
        </code>
      <p>
        The [capture] list supports the definition of closures. Such lambda expressions are defined in the standard as syntactic sugar for an unnamed function object.
      </p>

    </article>
  </section>
  <section class="main-section" id="Function_declarations">
    <header>Exception handling</header>
    <article>
      Exception handling is used to communicate the existence of a runtime problem or error from where it was detected to where the issue can be handled. It permits this to be done in a uniform manner and separately from the main code, while detecting all errors. Should an error occur, an exception is thrown (raised), which is then caught by the nearest suitable exception handler. The exception causes the current scope to be exited, and also each outer scope (propagation) until a suitable handler is found, calling in turn the destructors of any objects in these exited scopes. At the same time, an exception is presented as an object carrying the data about the detected problem.
      <p>
        Some C++ style guides, such as Google's, LLVM's,and Qt's forbid the usage of exceptions
      </p>
     The exception-causing code is placed inside a try block. The exceptions are handled in separate catch blocks (the handlers); each try block can have multiple exception handlers, as it is visible in the example below.
        
        <code>
          #include <iostream>
#include <vector>
#include <stdexcept>

int main() {
    try {
        std::vector<int> vec{3, 4, 3, 1};
        int i{vec.at(4)}; // Throws an exception, std::out_of_range (indexing for vec is from 0-3 not 1-4)
    }
    // An exception handler, catches std::out_of_range, which is thrown by vec.at(4)
    catch (std::out_of_range &e) {
        std::cerr << "Accessing a non-existent element: " << e.what() << '\n';
    }
    // To catch any other standard library exceptions (they derive from std::exception)
    catch (std::exception &e) {
        std::cerr << "Exception thrown: " << e.what() << '\n';
    }
    // Catch any unrecognised exceptions (i.e. those which don't derive from std::exception)
    catch (...) {
        std::cerr << "Some fatal error\n";
    }
}
        </code>
      
      It is also possible to raise exceptions purposefully, using the throw keyword; these exceptions are handled in the usual way. In some cases, exceptions cannot be used due to technical reasons. One such example is a critical component of an embedded system, where every operation must be guaranteed to complete within a specified amount of time. This cannot be determined with exceptions as no tools exist to determine the maximum time required for an exception to be handled.
          Unlike signal handling, in which the handling function is called from the point of failure, exception handling exits the current scope before the catch block is entered, which may be located in the current function or any of the previous function calls currently on the stack.
    </article>
  </section>
  <section class="main-section" id="Reference">
    <header>Reference</header>
    <article>
      <ul>
        <li>
          All the documentation in this page is taken from
          <a
            href="https://en.wikipedia.org/wiki/C%2B%2B"
            target="_blank"
            >wikipedia.org</a
          >
        </li>
      </ul>
    </article>
  </section>
</main>

</body>
</html>